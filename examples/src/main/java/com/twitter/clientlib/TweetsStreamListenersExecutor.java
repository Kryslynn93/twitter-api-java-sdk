/*
Copyright 2020 Twitter, Inc.
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
https://openapi-generator.tech
Do not edit the class manually.
*/


package com.twitter.clientlib;


import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import com.google.gson.reflect.TypeToken;

import com.twitter.clientlib.model.StreamingTweetResponse;

public class TweetsStreamListenersExecutor {
  private final static int TIMEOUT_MILLIS = 60000;
  private final static int SLEEP_MILLIS = 100;
  private final ITweetsQueue tweetsQueue;
  private final List<TweetsStreamListener> listeners = new ArrayList<>();
  private final InputStream stream;
  private final AtomicBoolean isRunning = new AtomicBoolean(true);
  private final AtomicLong tweetStreamedTime = new AtomicLong(0);
  private Exception caughtException;

  public TweetsStreamListenersExecutor(InputStream stream) {
    this.tweetsQueue = new LinkedListTweetsQueue();
    this.stream = stream;
  }

  public TweetsStreamListenersExecutor(ITweetsQueue tweetsQueue, InputStream stream) {
    this.tweetsQueue = tweetsQueue;
    this.stream = stream;
  }

  public void addListener(TweetsStreamListener toAdd) {
    listeners.add(toAdd);
  }

  public void executeListeners() {
    if (stream == null) {
      System.out.println("Error: stream is null.");
      return;
    } else if (this.tweetsQueue == null) {
      System.out.println("Error: tweetsQueue is null.");
      return;
    }

    TweetsQueuer tweetsQueuer = new TweetsQueuer();
    TweetsListenersExecutor tweetsListenersExecutor = new TweetsListenersExecutor();
    StreamTimeoutChecker timeoutChecker = new StreamTimeoutChecker();
    tweetsListenersExecutor.start();
    tweetsQueuer.start();
    timeoutChecker.start();
  }

  public void shutdown(Exception e) {
    caughtException = e;
    shutdown();
  }

  public void shutdown() {
    isRunning.set(false);
    System.out.println("TweetsStreamListenersExecutor is shutting down.");
  }

  public Exception getError() {
    return caughtException;
  }

  private void resetTweetStreamedTime() {
    tweetStreamedTime.set(System.currentTimeMillis());
  }

  private boolean isTweetStreamedError() {
    return System.currentTimeMillis() - tweetStreamedTime.get() > TIMEOUT_MILLIS;
  }

  private class TweetsListenersExecutor extends Thread {
    @Override
    public void run() {
      processTweets();
    }

    private void processTweets() {
      StreamingTweetResponse streamingTweet;
      String tweetString;
      try {
        while (isRunning.get()) {
          tweetString = tweetsQueue.poll();
          if (tweetString == null) {
            Thread.sleep(SLEEP_MILLIS);
            continue;
          }
          try {
            streamingTweet = StreamingTweetResponse.fromJson(tweetString);
            for (TweetsStreamListener listener : listeners) {
              listener.actionOnTweetsStream(streamingTweet);
            }
          } catch (Exception interExcep) {
            interExcep.printStackTrace();
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
        shutdown(e);
      }
    }
  }

  private class TweetsQueuer extends Thread {
    @Override
    public void run() {
      queueTweets();
    }

    public void queueTweets() {
      String line = null;
      try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {
        while (isRunning.get()) {
          line = reader.readLine();
          resetTweetStreamedTime();
          if(line == null || line.isEmpty()) {
            Thread.sleep(SLEEP_MILLIS);
            continue;
          }
          tweetsQueue.add(line);
        }
      } catch (Exception e) {
        e.printStackTrace();
        shutdown(e);
      }
    }
  }

  private class StreamTimeoutChecker extends Thread {
    @Override
    public void run() {
      checkTimes();
    }

    public void checkTimes()  {
      resetTweetStreamedTime();
      while (isRunning.get()) {
        if(isTweetStreamedError()) {
          shutdown(new ApiException("Tweets are not streaming"));
        }
        try {
          Thread.sleep(SLEEP_MILLIS);
        } catch (InterruptedException interExcep) {
          interExcep.printStackTrace();
        }
      }
    }
  }
}

interface ITweetsQueue {
  String poll();
  void add(String streamingTweet);
}

class LinkedListTweetsQueue implements ITweetsQueue {
  private final Queue<String> tweetsQueue = new LinkedList<>();

  @Override
  public String poll() {
    return tweetsQueue.poll();
  }

  @Override
  public void add(String streamingTweet) {
    tweetsQueue.add(streamingTweet);
  }
}
